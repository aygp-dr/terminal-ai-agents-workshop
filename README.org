#+TITLE: Terminal AI Agents Workshop
#+AUTHOR: aygp-dr
#+OPTIONS: toc:2 num:nil

* Overview

A comprehensive workshop for building terminal-based AI agents with LLM tool calling, featuring implementations in Python and Scheme with literate programming via Org-mode.

[[https://github.com/aygp-dr/terminal-ai-agents-workshop][https://img.shields.io/badge/python-3.11+-blue.svg]]
[[https://github.com/aygp-dr/terminal-ai-agents-workshop][https://img.shields.io/badge/uv-package_manager-green.svg]]
[[https://github.com/aygp-dr/terminal-ai-agents-workshop][https://img.shields.io/badge/org--mode-literate_programming-purple.svg]]

* Features

- ðŸ¤– Complete terminal AI agent implementations
- ðŸ› ï¸ Extensible tool system for file operations, git, web search
- ðŸ“š Literate programming with Org-mode
- ðŸ Python and Scheme (Guile) implementations
- ðŸ§ª Comprehensive testing framework
- ðŸ“Š Agent comparison and benchmarking tools
- ðŸ”§ Full Emacs integration with project-specific configuration

* Quick Start

** Prerequisites

- Python 3.11+
- =uv= package manager
- Emacs (optional, for Org-mode features)
- Git

** Installation

#+begin_src bash
# Clone the repository
git clone https://github.com/aygp-dr/terminal-ai-agents-workshop.git
cd terminal-ai-agents-workshop

# Install dependencies with uv
gmake dev

# Or manually
uv sync

# Install pre-commit hooks
gmake setup
#+end_src

** Running the Workshop

#+begin_src bash
# Run the minimal agent
uv run python src/labs/minimal_agent.py

# Run the complete agent
uv run python src/examples/complete_agent.py

# Run tests
gmake test

# Run linting and formatting
gmake lint format
#+end_src

* Project Structure

#+begin_example
terminal-ai-agents-workshop/
â”œâ”€â”€ setup.org                 # Literate programming source
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ patterns/            # Agent design patterns
â”‚   â”‚   â””â”€â”€ basic_tool.py    # Tool calling pattern
â”‚   â”œâ”€â”€ labs/                # Workshop exercises
â”‚   â”‚   â”œâ”€â”€ minimal_agent.py # Minimal implementation
â”‚   â”‚   â””â”€â”€ agent_comparison.py # Benchmarking
â”‚   â”œâ”€â”€ tools/               # Tool implementations
â”‚   â”‚   â”œâ”€â”€ file_operations.py
â”‚   â”‚   â”œâ”€â”€ git_operations.py
â”‚   â”‚   â”œâ”€â”€ project_analysis.py
â”‚   â”‚   â””â”€â”€ web_search.py
â”‚   â””â”€â”€ examples/            # Complete examples
â”‚       â””â”€â”€ complete_agent.py
â”œâ”€â”€ tests/                   # Test suite
â”œâ”€â”€ scripts/                 # Setup and utility scripts
â””â”€â”€ Makefile                # Development commands
#+end_example

* Workshop Labs

** Lab 1: Building a Minimal Agent

Learn the fundamentals of tool-calling agents by building a minimal implementation that can read files and execute shell commands.

#+begin_src python
from src.labs.minimal_agent import MinimalAgent

agent = MinimalAgent(api_key="your-key")
response = agent.chat("List all Python files in the current directory")
#+end_src

** Lab 2: Implementing Tool Patterns

Explore different tool patterns including file operations, project analysis, and web search integration.

** Lab 3: Agent Comparison

Benchmark different terminal AI agents (Claude Code, Aider, Amp, Gemini CLI) on common development tasks.

** Lab 4: Building Custom Tools

Create your own tools for specific workflows and integrate them with the agent framework.

* Development

** Available Make Targets

#+begin_src bash
make help      # Show all available commands
make dev       # Install development dependencies
make test      # Run test suite
make lint      # Run linting checks
make format    # Format code
make typecheck # Run type checking with pyright
make clean     # Clean cache and build files
make docs      # Generate documentation
#+end_src

** Emacs Integration

The project includes comprehensive Emacs configuration:

- =.dir-locals.el= - Project-specific settings
- =.projectile= - Project navigation
- Automatic =uv= integration for Python shells
- Configured flycheck and LSP support

** Literate Programming

The main workshop content is written in =setup.org= using literate programming. To extract (tangle) the source code:

#+begin_src bash
# Using Emacs
emacs --batch -l org setup.org -f org-babel-tangle

# Or using the Makefile
make tangle
#+end_src

* Tool System

** Core Tools

| Tool | Purpose | Example Usage |
|------+---------+---------------|
| =create_file= | Create new files | Generate boilerplate code |
| =edit_file= | Modify existing files | Apply fixes and refactoring |
| =list_directory= | Browse project structure | Understand codebase layout |
| =run_command= | Execute shell commands | Run tests, builds |
| =git_operations= | Version control | Commit, diff, branch management |
| =web_search= | Search and fetch web content | Find documentation, examples |
| =project_analysis= | Analyze code structure | Find TODOs, analyze imports |

** Creating Custom Tools

#+begin_src python
from typing import Dict, Any

def my_custom_tool(param1: str, param2: int) -> str:
    """Your custom tool implementation"""
    # Tool logic here
    return f"Processed {param1} with {param2}"

# Register with agent
agent.tools.register(Tool(
    name="my_tool",
    description="Description for LLM",
    parameters={
        "type": "object",
        "properties": {
            "param1": {"type": "string"},
            "param2": {"type": "integer"}
        }
    },
    function=my_custom_tool
))
#+end_src

* API Keys

Set up your API keys in environment variables or =.env= file:

#+begin_src bash
export ANTHROPIC_API_KEY="your-key"
export OPENAI_API_KEY="your-key"
export GEMINI_API_KEY="your-key"
#+end_src

* Contributing

Contributions are welcome! Please:

1. Fork the repository
2. Create a feature branch
3. Run tests and linting
4. Submit a pull request

* Resources

** Terminal AI Agents

*** Agent Comparison Matrix

| Agent | Version | Provider | Interface | Key Features |
|-------+---------+----------+-----------+--------------|
| [[https://github.com/anthropics/claude-code][Claude Code]] | 2.0.75 | Anthropic | CLI/Terminal | Agentic coding, file ops, bash, multi-tool orchestration |
| [[https://docs.github.com/en/copilot/using-github-copilot/using-github-copilot-in-the-command-line][GitHub Copilot CLI]] | 1.1.1 | GitHub/Microsoft | CLI (=gh copilot=) | Explain/suggest commands, shell integration |
| [[https://github.com/google-gemini/gemini-cli][Gemini CLI]] | 0.1.7 | Google | CLI/Terminal | Gemini 2.5 Pro, Google ecosystem, multimodal |
| [[https://github.com/paul-gauthier/aider][Aider]] | - | Open Source | CLI/Terminal | Git-aware, multi-file editing, many LLM backends |
| [[https://github.com/sourcegraph/amp][Amp]] | - | Sourcegraph | CLI/Terminal | Code search, multi-repo context, Cody-based |
| [[https://github.com/All-Hands-AI/OpenHands][OpenHands]] | - | Open Source | Terminal/Web | Full development capabilities, sandboxed execution |
| [[https://github.com/steveyegge/efrit][Efrit]] | 0.4.1 | Steve Yegge | Emacs | Native Elisp agent, 35+ tools, Claude-powered |

*** Efrit - Native Emacs AI Agent

Efrit is a *pure Elisp coding agent* that brings Claude directly into Emacs. Core philosophy: /"Claude makes all decisions, Efrit executes."/

*Key Features:*
- 35+ tools: code execution, file editing, codebase exploration, git, shell
- Three modes: =efrit-chat= (conversation), =efrit-do= (quick tasks), =efrit-agent= (complex projects)
- Safety controls: checkpoints, confirmations, timeout limits, shell restrictions
- AI-to-AI communication via MCP file-based JSON queue

*Installation:*

#+begin_src elisp
(use-package efrit
  :load-path "~/path/to/efrit/lisp"
  :commands (efrit-chat efrit-do efrit-agent efrit-remote-queue-start)
  :bind (("C-c C-e c" . efrit-chat)
         ("C-c C-e d" . efrit-do)
         ("C-c C-e a" . efrit-agent)
         ("C-c C-e q" . efrit-remote-queue-start))
  :config
  (setq efrit-default-model "claude-sonnet-4-5-20250929"))
#+end_src

*MCP Queue Communication:*

Other AI agents (Claude Code, Cursor, etc.) can interact with Efrit via file-based JSON queues:

#+begin_example
~/.emacs.d/.efrit/
â”œâ”€â”€ queues/
â”‚   â”œâ”€â”€ requests/    # Drop JSON requests here
â”‚   â”œâ”€â”€ processing/  # Currently being processed
â”‚   â”œâ”€â”€ responses/   # Completed responses
â”‚   â””â”€â”€ archive/     # Historical requests
#+end_example

Request format:

#+begin_src json
{
  "id": "req_001",
  "version": "1.0.0",
  "type": "eval",
  "content": "(buffer-name)",
  "timestamp": "2025-12-21T12:00:00Z"
}
#+end_src

Types: =eval= (elisp), =command= (natural language), =chat= (conversation), =status= (health check)

*Emacs Versions Tested:* 28.2, 29.4, 30.1

** Research Papers and Literature
- [[file:research/reading-list.org][Comprehensive Reading List]] - Annotated bibliography of 40+ papers
- [[https://arxiv.org/abs/2210.03629][ReAct: Reasoning and Acting (2022)]] - Foundational paradigm
- [[https://arxiv.org/abs/2405.15793][SWE-agent (2024)]] - Software engineering agents
- [[https://www.swebench.com][SWE-bench]] - Real-world software engineering benchmark

** Documentation
- [[https://docs.anthropic.com/claude/docs/tool-use][Anthropic Tool Use]]
- [[https://platform.openai.com/docs/guides/function-calling][OpenAI Function Calling]]
- [[https://ghuntley.com/agent/][How to build an agent]]

* License

MIT License - See LICENSE file for details

* Acknowledgments

- Workshop inspired by the terminal AI agent pattern pioneered by Geoffrey Huntley
- Scheme implementation based on patterns from =guile-ampcode-agent=
- Community contributions from workshop participants

* Contact

- Repository: [[https://github.com/aygp-dr/terminal-ai-agents-workshop]]
- Issues: [[https://github.com/aygp-dr/terminal-ai-agents-workshop/issues]]
- Collaborators: @jwalsh, @seanjensengrey